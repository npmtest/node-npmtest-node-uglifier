{"/home/travis/build/npmtest/node-npmtest-node-uglifier/test.js":"/* istanbul instrument in package npmtest_node_uglifier */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-uglifier/lib.npmtest_node_uglifier.js":"/* istanbul instrument in package npmtest_node_uglifier */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_node_uglifier = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_node_uglifier = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-node-uglifier/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-node-uglifier && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_node_uglifier */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_node_uglifier\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_node_uglifier.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_node_uglifier.rollup.js'] =\n            local.assetsDict['/assets.npmtest_node_uglifier.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_node_uglifier.__dirname +\n                    '/lib.npmtest_node_uglifier.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-uglifier/node_modules/node-uglifier/index.js":"\n/**\n * Export NodeUglifier (with )\n */\n\nexports = module.exports = require('./lib_compiled/NodeUglifier.js');\n\n/*\n Export the version\n */\n\nexports.version = require('./package').version;","/home/travis/build/npmtest/node-npmtest-node-uglifier/node_modules/node-uglifier/lib_compiled/NodeUglifier.js":"// Generated by CoffeeScript 1.10.0\n(function() {\n  var Errors, Graph, NodeUglifier, UGLIFY_SOURCE_MAP_TOKEN, UglifyJS, _, cryptoUtils, fs, fsExtra, packageUtils, path, saltLength, sugar, util,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  Errors = require(\"./libs/Errors\");\n\n  Graph = require(\"./libs/js-graph-mod/src/js-graph\");\n\n  fsExtra = require('fs-extra');\n\n  fs = require('fs');\n\n  _ = require('underscore');\n\n  sugar = require('sugar');\n\n  sugar.extend();\n\n  path = require('path');\n\n  packageUtils = require('./libs/packageUtils');\n\n  cryptoUtils = require('./libs/cryptoUtils');\n\n  UglifyJS = require('uglify-js-harmony');\n\n  util = require(\"util\");\n\n  saltLength = 20;\n\n  UGLIFY_SOURCE_MAP_TOKEN = \"UGLIFY_SOURCE_MAP_TOKEN\";\n\n\n  /* mergeFileFilterWithExport */\n\n  NodeUglifier = (function() {\n    function NodeUglifier(mainFile, options) {\n      var j, results;\n      if (options == null) {\n        options = {};\n      }\n      this.getRequireSubstitutionForFilteredWithExport = bind(this.getRequireSubstitutionForFilteredWithExport, this);\n      this.getNewRelativePathForFiltered = bind(this.getNewRelativePathForFiltered, this);\n      this.getNewRelativePathForFilteredWithExport = bind(this.getNewRelativePathForFilteredWithExport, this);\n      this.options = {\n        mergeFileFilterWithExport: [],\n        mergeFileFilter: [],\n        newFilteredFileDir: \"./lib_external\",\n        containerName: \"cachedModules\",\n        rngSeed: null,\n        licenseFile: null,\n        fileExtensions: [\"js\", \"coffee\", \"json\"],\n        suppressFilteredDependentError: false,\n        packNodeModules: false\n      };\n      _.extend(this.options, options);\n      this.mainFileAbs = path.resolve(mainFile) || path.resolve(process.cwd(), mainFile);\n      if (!fs.existsSync(this.mainFileAbs)) {\n        throw new Error(\"main file not found \" + this.mainFileAbs);\n      } else {\n        console.log(\"processing main file: \" + this.mainFileAbs);\n      }\n      this.salt = cryptoUtils.generateSalt(saltLength);\n      this.hashAlgorithm = \"sha1\";\n      this.wrappedSourceContainerName = this.options.containerName;\n      this.serialMappings = cryptoUtils.shuffleArray((function() {\n        results = [];\n        for (j = 0; j <= 10000; j++){ results.push(j); }\n        return results;\n      }).apply(this), this.options.rngSeed);\n      this._sourceCodes = {};\n      this.statistics = {};\n      this.filteredOutFiles = packageUtils.getMatchingFiles(this.mainFileAbs, this.options.mergeFileFilter);\n      this.lastResult = null;\n    }\n\n    NodeUglifier.prototype.getSourceContainer = function(serial) {\n      return this.wrappedSourceContainerName + \"[\" + this.serialMappings[serial] + \"]\";\n    };\n\n    NodeUglifier.prototype.getRequireSubstitutionForMerge = function(serial) {\n      return this.getSourceContainer(serial) + \".exports\";\n    };\n\n    NodeUglifier.prototype.getNewRelativePathForFilteredWithExport = function(pathAbs) {\n      return path.join(this.options.newFilteredFileDir, path.basename(pathAbs));\n    };\n\n    NodeUglifier.prototype.getNewRelativePathForFiltered = function(pathAbs) {\n      var relPath;\n      relPath = path.relative(path.dirname(this.mainFileAbs), path.dirname(pathAbs));\n      return path.join(relPath, path.basename(pathAbs));\n    };\n\n    NodeUglifier.prototype.getRequireSubstitutionForFilteredWithExport = function(pathAbs, relPathFn) {\n      var relFile, relFileNoExt;\n      relFile = relPathFn(pathAbs);\n      relFileNoExt = relFile.replace(path.extname(relFile), \"\");\n      return \"require('./\" + relFileNoExt.replace(/\\\\/g, \"/\") + \"')\";\n    };\n\n    NodeUglifier.prototype.addWrapper = function(source, serial) {\n      var firstLine, lastLine, modulesArrayStr, secondLine;\n      modulesArrayStr = this.getSourceContainer(serial);\n      firstLine = modulesArrayStr + \"={exports:{}};\" + \"\\n\";\n      secondLine = \"(function(module,exports) {\";\n      lastLine = \"}).call(this,\" + modulesArrayStr + \",\" + modulesArrayStr + \".exports);\";\n      return \"\\n\" + firstLine + secondLine + source + lastLine;\n    };\n\n    NodeUglifier.prototype.merge = function() {\n      var _this, depGraph, edgeToRemove, error, filteredOutFilesWithExport, firstLine, iter, me, r, recursiveSourceGrabber, wasCycle;\n      _this = this;\n      firstLine = \"var \" + this.wrappedSourceContainerName + \"=[];\";\n      r = {\n        source: firstLine,\n        filteredOutFilesObj: {},\n        sourceMapModules: {},\n        pathOrder: [],\n        cycles: []\n      };\n      depGraph = new Graph();\n      filteredOutFilesWithExport = packageUtils.getMatchingFiles(this.mainFileAbs, this.options.mergeFileFilterWithExport);\n      recursiveSourceGrabber = function(filePath) {\n        var ast, basename, error, error1, error2, filteredOutFilesObj, isSourceObjDepFiltered, isSourceObjDepFilteredWithExport, isSourceObjFiltered, isSourceObjFilteredWithExport, j, len, me, msg, otherSerial, pathSaltedHash, relPathFnc, replacement, requireStatement, requireStatements, source, sourceObj, sourceObjDep;\n        try {\n          depGraph.addNewVertex(filepath, filepath);\n        } catch (error) {\n          me = error;\n        }\n        source = packageUtils.readFile(filePath).toString();\n        if (_.isEqual(path.extname(filePath), \".json\")) {\n          source = \"module.exports=(\" + source + \");\";\n        }\n        pathSaltedHash = cryptoUtils.getSaltedHash(filePath, _this.hashAlgorithm, _this.salt);\n        if (_this._sourceCodes[pathSaltedHash] == null) {\n          _this._sourceCodes[pathSaltedHash] = {\n            source: source,\n            serial: _.keys(_this._sourceCodes).length,\n            sourceMod: source\n          };\n          console.log(filePath + \" added to sources \");\n        }\n        sourceObj = _this._sourceCodes[pathSaltedHash];\n        isSourceObjFilteredWithExport = filteredOutFilesWithExport.filter(function(fFile) {\n          return path.normalize(fFile) === path.normalize(filePath);\n        }).length > 0;\n        isSourceObjFiltered = _this.filteredOutFiles.filter(function(fFile) {\n          return path.normalize(fFile) === path.normalize(filePath);\n        }).length > 0;\n        ast = packageUtils.getAst(source);\n        requireStatements = packageUtils.getRequireStatements(ast, filePath, _this.fileExtensions, _this.options.packNodeModules);\n        requireStatements.forEach(function(o, i) {\n          return requireStatements[i] = _.extend(o, {\n            pathSaltedHash: cryptoUtils.getSaltedHash(o.path, _this.hashAlgorithm, _this.salt)\n          });\n        });\n        for (j = 0, len = requireStatements.length; j < len; j++) {\n          requireStatement = requireStatements[j];\n          try {\n            depGraph.addNewVertex(requireStatement.path, null);\n          } catch (error1) {\n            me = error1;\n          }\n          try {\n            depGraph.addNewEdge(filePath, requireStatement.path);\n          } catch (error2) {\n            me = error2;\n          }\n          sourceObjDep = _this._sourceCodes[requireStatement.pathSaltedHash];\n          if (isSourceObjFilteredWithExport && packageUtils.getIfNonNativeNotFilteredNonNpm(requireStatement.path, filteredOutFilesWithExport, _this.options.fileExtensions)) {\n            msg = \"filtered files can not have dependency on merged files, file: \" + filePath + \" dependency: \" + requireStatement.path;\n            if (_this.options.suppressFilteredDependentError) {\n              console.warn(msg);\n            } else {\n              throw new Error(msg);\n            }\n          }\n          if (sourceObjDep == null) {\n            recursiveSourceGrabber(requireStatement.path);\n          }\n          sourceObjDep = _this._sourceCodes[requireStatement.pathSaltedHash];\n          if (sourceObjDep == null) {\n            throw new Error(\" internal should not happen 1\");\n          }\n          otherSerial = sourceObjDep.serial;\n          isSourceObjDepFilteredWithExport = filteredOutFilesWithExport.filter(function(fFile) {\n            return path.normalize(fFile) === path.normalize(requireStatement.path);\n          }).length > 0;\n          isSourceObjDepFiltered = _this.filteredOutFiles.filter(function(fFile) {\n            return path.normalize(fFile) === path.normalize(requireStatement.path);\n          }).length > 0;\n          if (isSourceObjDepFilteredWithExport) {\n            replacement = _this.getRequireSubstitutionForFilteredWithExport(requireStatement.path, _this.getNewRelativePathForFilteredWithExport);\n          } else if (isSourceObjDepFiltered) {\n            replacement = _this.getRequireSubstitutionForFilteredWithExport(requireStatement.path, _this.getNewRelativePathForFiltered);\n          } else {\n            replacement = _this.getRequireSubstitutionForMerge(otherSerial);\n            r.sourceMapModules[_this.getSourceContainer(otherSerial)] = path.relative(path.dirname(_this.mainFileAbs), requireStatement.path);\n          }\n          sourceObj.sourceMod = packageUtils.replaceRequireStatement(sourceObj.sourceMod, requireStatement.text, replacement);\n        }\n        if (isSourceObjFilteredWithExport || isSourceObjFiltered) {\n          if (isSourceObjFiltered) {\n            relPathFnc = _this.getNewRelativePathForFiltered;\n            basename = relPathFnc(filePath);\n          } else if (isSourceObjFilteredWithExport) {\n            relPathFnc = _this.getNewRelativePathForFilteredWithExport;\n            basename = path.basename(filePath);\n          }\n          if (r.filteredOutFilesObj[basename]) {\n            filteredOutFilesObj = r.filteredOutFilesObj[basename];\n            if (filteredOutFilesObj.serial !== sourceObj.serial) {\n              throw new Error(\" external files with same filename not supported yet\");\n            }\n          } else {\n            r.filteredOutFilesObj[basename] = {\n              pathRel: relPathFnc(filePath)\n            };\n            return _.extend(r.filteredOutFilesObj[basename], sourceObj);\n          }\n        } else {\n          if (sourceObj.serial > 0) {\n            sourceObj.sourceModWrapped = _this.addWrapper(sourceObj.sourceMod, sourceObj.serial);\n          } else {\n            sourceObj.sourceModWrapped = sourceObj.sourceMod;\n          }\n          r.pathOrder.push(filePath);\n          return r.source = r.source + sourceObj.sourceModWrapped;\n        }\n      };\n      recursiveSourceGrabber(this.mainFileAbs);\n      this.lastResult = r;\n      wasCycle = true;\n      iter = 0;\n      while (wasCycle && iter < 1000) {\n        iter++;\n        wasCycle = false;\n        try {\n          depGraph.topologically(function(vertex, vertexVal) {});\n        } catch (error) {\n          me = error;\n          wasCycle = true;\n          if (me.cycle) {\n            r.cycles.push(me.cycle);\n            edgeToRemove = [me.cycle.last(2).last(), me.cycle.last(2).first()].reverse();\n            depGraph.removeEdge.apply(depGraph, edgeToRemove);\n          }\n        }\n      }\n      if (!_.isEmpty(r.cycles)) {\n        throw new Errors.CyclicDependencies(r.cycles);\n      }\n      return this;\n    };\n\n    NodeUglifier.prototype.exportDependencies = function(exportDir, srcDirMap) {\n      var baseDir, baseName, baseNameNoExtension, baseNameOther, exportDirAbs, extension, from, fromToMap, j, k, len, len1, mirrorExt, newFile, newFileOther, otherBaseDir, otherFile, p, projectDir, ref, results, sourceFileDidNotExist, sourceFileDidNotExistArr, to, toFromMap;\n      if (srcDirMap == null) {\n        srcDirMap = null;\n      }\n      sourceFileDidNotExistArr = [];\n      if (!this.lastResult) {\n        this.merge();\n      }\n      if (!this.lastResult.pathOrder) {\n        throw new Error(\"there was no dependencies to export\");\n        return;\n      }\n      exportDirAbs = path.resolve(exportDir) || path.resolve(process.cwd(), exportDir);\n      projectDir = process.cwd();\n      ref = this.lastResult.pathOrder;\n      for (j = 0, len = ref.length; j < len; j++) {\n        p = ref[j];\n        if (p.indexOf(projectDir) !== 0) {\n          throw new Error(p + \" dependency not found each dependency should be in the project Dir: \" + projectDir);\n        }\n        baseDir = path.dirname(p.slice(projectDir.length + 1));\n        baseName = path.basename(p);\n        extension = path.extname(p);\n        baseNameNoExtension = baseName.slice(0, +(baseName.length - extension.length - 1) + 1 || 9e9);\n        newFile = path.resolve(path.join(exportDirAbs, baseDir, baseName));\n        fsExtra.ensureDirSync(path.dirname(newFile));\n        fs.createReadStream(p).pipe(fs.createWriteStream(newFile));\n        if (srcDirMap) {\n          for (mirrorExt in srcDirMap) {\n            fromToMap = srcDirMap[mirrorExt];\n            toFromMap = _.invert(fromToMap);\n            for (to in toFromMap) {\n              from = toFromMap[to];\n              otherBaseDir = baseDir.replace(to, from);\n              if (otherBaseDir === baseDir) {\n                continue;\n              }\n              otherFile = path.join(path.resolve(process.cwd(), otherBaseDir), baseNameNoExtension + \".\" + mirrorExt);\n              baseNameOther = path.basename(otherFile);\n              if (fsExtra.existsSync(otherFile)) {\n                newFileOther = path.resolve(path.join(exportDirAbs, otherBaseDir, baseNameOther));\n                fsExtra.ensureDirSync(path.dirname(newFileOther));\n                fs.createReadStream(otherFile).pipe(fs.createWriteStream(newFileOther));\n              } else {\n                sourceFileDidNotExistArr.push(otherFile);\n              }\n              console.log(otherFile);\n            }\n          }\n        }\n      }\n      results = [];\n      for (k = 0, len1 = sourceFileDidNotExistArr.length; k < len1; k++) {\n        sourceFileDidNotExist = sourceFileDidNotExistArr[k];\n        results.push(console.log(\"WARNING source file did not exist: \" + sourceFileDidNotExist));\n      }\n      return results;\n    };\n\n    NodeUglifier.prototype.toString = function() {\n      return this.lastResult.source.toString();\n    };\n\n    NodeUglifier.prototype.exportToFile = function(file) {\n      var _this, outDirRoot, outFileAbs;\n      _this = this;\n      outFileAbs = path.resolve(file);\n      fsExtra.ensureDirSync(path.dirname(outFileAbs));\n      fs.writeFileSync(outFileAbs, this.toString());\n      outDirRoot = path.dirname(outFileAbs);\n      _.keys(_this.lastResult.filteredOutFilesObj).forEach(function(fileName) {\n        var copyObj, newFile;\n        copyObj = _this.lastResult.filteredOutFilesObj[fileName];\n        newFile = path.resolve(outDirRoot, copyObj.pathRel);\n        fsExtra.ensureDirSync(path.dirname(newFile));\n        return fs.writeFileSync(newFile, copyObj.sourceMod);\n      });\n      return _this.filteredOutFiles.forEach(function(fileName) {\n        var newFile, pathRel;\n        pathRel = _this.getNewRelativePathForFiltered(fileName);\n        newFile = path.resolve(outDirRoot, pathRel);\n        fsExtra.ensureDirSync(path.dirname(newFile));\n        return fs.createReadStream(fileName).pipe(fs.createWriteStream(newFile));\n      });\n    };\n\n    NodeUglifier.prototype.exportSourceMaps = function(file) {\n      var _this, dir, outFileAbs, sourceMapModulesOutFileName, sourceMapOutFileName;\n      _this = this;\n      outFileAbs = path.resolve(file);\n      sourceMapOutFileName = path.basename(outFileAbs) + \".map\";\n      sourceMapModulesOutFileName = path.basename(outFileAbs) + \".modules-map\";\n      dir = path.dirname(outFileAbs);\n      fsExtra.ensureDirSync(dir);\n      if (this.lastResult.sourceMapUglify != null) {\n        fs.writeFileSync(path.join(dir, sourceMapOutFileName), this.lastResult.sourceMapUglify.replace(UGLIFY_SOURCE_MAP_TOKEN, sourceMapOutFileName));\n      }\n      return fs.writeFileSync(path.join(dir, sourceMapModulesOutFileName), JSON.stringify(_this.lastResult.sourceMapModules));\n    };\n\n    NodeUglifier.prototype.uglify = function(optionsIn) {\n      var a, ast, options, res, source;\n      if (optionsIn == null) {\n        optionsIn = {};\n      }\n      if (!this.lastResult) {\n        this.merge();\n      }\n      options = {\n        mangle: true,\n        compress: {\n          drop_console: false,\n          hoist_funs: true,\n          loops: true,\n          evaluate: true,\n          conditionals: true\n        },\n        output: {\n          comments: false\n        },\n        strProtectionLvl: 0\n      };\n      _.extend(options, optionsIn);\n      if (!this.lastResult.source) {\n        return;\n      }\n      source = this.toString();\n      a = 1 + 1;\n      res = UglifyJS.minify(source, _.extend({\n        fromString: true,\n        outSourceMap: UGLIFY_SOURCE_MAP_TOKEN\n      }, options));\n      this.lastResult.source = res.code;\n      this.lastResult.sourceMapUglify = res.map;\n      switch (options.strProtectionLvl) {\n        case 1:\n          ast = packageUtils.getAst(this.lastResult.source);\n          this.lastResult.source = packageUtils.getSourceHexified(ast);\n      }\n      return this;\n    };\n\n    return NodeUglifier;\n\n  })();\n\n  module.exports = NodeUglifier;\n\n}).call(this);\n\n//# sourceMappingURL=NodeUglifier.js.map\n","/home/travis/build/npmtest/node-npmtest-node-uglifier/node_modules/node-uglifier/lib_compiled/libs/Errors.js":"// Generated by CoffeeScript 1.10.0\n(function() {\n  var CyclicDependencies, util,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  util = require(\"util\");\n\n  CyclicDependencies = (function(superClass) {\n    extend(CyclicDependencies, superClass);\n\n    function CyclicDependencies(cyclesArrOfArr) {\n      var msg;\n      this.name = 'CyclicDependencies';\n      this.cycles = cyclesArrOfArr;\n      msg = \"There has been \" + cyclesArrOfArr.length + \" cycles in the dependency tree: \\n\" + util.inspect(cyclesArrOfArr, {\n        showHidden: true,\n        depth: null\n      });\n      return CyclicDependencies.__super__.constructor.call(this, msg);\n    }\n\n    return CyclicDependencies;\n\n  })(Error);\n\n  module.exports.CyclicDependencies = CyclicDependencies;\n\n}).call(this);\n\n//# sourceMappingURL=Errors.js.map\n","/home/travis/build/npmtest/node-npmtest-node-uglifier/node_modules/node-uglifier/lib_compiled/libs/js-graph-mod/src/js-graph.js":"'use strict';\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//\n// Using the Universal Module Definition `returnExports.js`\n// to support AMD, Node, as well as browser globals:\n// https://github.com/umdjs/umd/blob/master/returnExports.js\n//\n(function (root, name, factory) {\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine([], factory);\n\t} else if (typeof exports === 'object') {\n\t\tmodule.exports = factory();\n\t} else {\n\t\troot[name] = factory();\n\t}\n}(this, 'JsGraph', function () {////////////////////////////////////////////////////////////////////////////////////////\n\n\n//  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//  // JsGraph class ///////////////////////////////////////////////////////////////////////////////////////////////////\n//  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\tfunction JsGraph() {\n\n\n\t\tvar that = this;\n\n\n//      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//      // Private Variables ///////////////////////////////////////////////////////////////////////////////////////////\n//      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\t\tvar _vertices = {};     // key -> value\n\n\t\tvar _edges = {};        // from -> to -> value\n\n\t\tvar _reverseEdges = {}; // to -> from -> null (_edges contains the values)\n\n\t\tvar _vertexCount = 0;\n\n\t\tvar _edgeCount = 0;\n\n\n//      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//      // Privileged Methods //////////////////////////////////////////////////////////////////////////////////////////\n//      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\t\t//////////////////////////////\n\t\t////////// Vertices //////////\n\t\t//////////////////////////////\n\n\n\t\tvar _addVertexCallbacks    = new Callbacks();\n\t\tvar _removeVertexCallbacks = new Callbacks();\n\n\n\t\t//// listening for them ////\n\t\t//\n\t\tthat.onAddVertex    = _addVertexCallbacks.add;\n\t\tthat.onRemoveVertex = _removeVertexCallbacks.add;\n\n\n\t\t//// creating them ////\n\t\t//\n\t\tthat.addNewVertex = function (key, value) {\n\t\t\tif (that.hasVertex(key)) {\n\t\t\t\tthrow new JsGraph.VertexExistsError(key, _vertices[key]);\n\t\t\t}\n\n\t\t\t_vertices[key] = value;\n\t\t\t_edges[key] = {};\n\t\t\t_reverseEdges[key] = {};\n\t\t\t_vertexCount += 1;\n\t\t\t_addVertexCallbacks.fire(key, value);\n\t\t};\n\n\t\tthat.setVertex = function (key, value) {\n\t\t\tif (!that.hasVertex(key)) {\n\t\t\t\tthrow new JsGraph.VertexNotExistsError(key);\n\t\t\t}\n\n\t\t\t_vertices[key] = value;\n\t\t};\n\n\t\tthat.ensureVertex = function (key, value) {\n\t\t\tif (!that.hasVertex(key)) {\n\t\t\t\tthat.addNewVertex(key, value);\n\t\t\t}\n\t\t};\n\n\t\tthat.addVertex = function (key, value) {\n\t\t\tif (that.hasVertex(key)) {\n\t\t\t\tthat.setVertex(key, value);\n\t\t\t} else {\n\t\t\t\tthat.addNewVertex(key, value);\n\t\t\t}\n\t\t};\n\n\n\t\t//// removing them ////\n\t\t//\n\t\tthat.removeExistingVertex = function (key) {\n\t\t\tif (!that.hasVertex(key)) {\n\t\t\t\tthrow new JsGraph.VertexNotExistsError(key);\n\t\t\t}\n\t\t\tif (Object.keys(_edges[key]).length) {\n\t\t\t\tthrow new JsGraph.HasConnectedEdgesError(key);\n\t\t\t}\n\t\t\tif (Object.keys(_reverseEdges[key]).length) {\n\t\t\t\tthrow new JsGraph.HasConnectedEdgesError(key);\n\t\t\t}\n\n\t\t\tvar valueOfRemovedVertex = _vertices[key];\n\t\t\tdelete _vertices[key];\n\t\t\t_vertexCount -= 1;\n\t\t\t_removeVertexCallbacks.fire(key, valueOfRemovedVertex);\n\t\t};\n\n\t\tthat.destroyExistingVertex = function (key) {\n\t\t\tif (!that.hasVertex(key)) {\n\t\t\t\tthrow new JsGraph.VertexNotExistsError(key);\n\t\t\t}\n\n\t\t\tthat.eachVertexFrom(key, function (to) {\n\t\t\t\tthat.removeEdge(key, to);\n\t\t\t});\n\t\t\tthat.eachVertexTo(key, function (from) {\n\t\t\t\tthat.removeEdge(from, key);\n\t\t\t});\n\t\t\tthat.removeExistingVertex(key);\n\t\t};\n\n\t\tthat.removeVertex = function (key) {\n\t\t\tif (that.hasVertex(key)) {\n\t\t\t\tthat.removeExistingVertex(key);\n\t\t\t}\n\t\t};\n\n\t\tthat.destroyVertex = function (key) {\n\t\t\tif (that.hasVertex(key)) {\n\t\t\t\tthat.destroyExistingVertex(key);\n\t\t\t}\n\t\t};\n\n\n\t\t///////////////////////////\n\t\t////////// Edges //////////\n\t\t///////////////////////////\n\n\n\t\tvar _addEdgeCallbacks    = new Callbacks();\n\t\tvar _removeEdgeCallbacks = new Callbacks();\n\n\n\t\t//// listening for them ////\n\t\t//\n\t\tthat.onAddEdge    = _addEdgeCallbacks.add;\n\t\tthat.onRemoveEdge = _removeEdgeCallbacks.add;\n\n\n\t\t//// creating them ////\n\t\t//\n\t\tthat.addNewEdge = function (from, to, value) {\n\t\t\tif (that.hasEdge(from, to)) {\n\t\t\t\tthrow new JsGraph.EdgeExistsError(from, to, that.edgeValue(from, to));\n\t\t\t}\n\t\t\tif (!that.hasVertex(from)) {\n\t\t\t\tif (that.hasVertex(to)) {\n\t\t\t\t\tthrow new JsGraph.VertexNotExistsError(from);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new JsGraph.VertexNotExistsError(from).v(to);\n\t\t\t\t}\n\t\t\t} else if (!that.hasVertex(to)) {\n\t\t\t\tthrow new JsGraph.VertexNotExistsError(to);\n\t\t\t}\n\n\t\t\t_edges[from][to] = value;\n\t\t\t_reverseEdges[to][from] = null;\n\t\t\t_edgeCount += 1;\n\t\t\t_addEdgeCallbacks.fire(from, to, value);\n\t\t};\n\n\t\tthat.createNewEdge = function (from, to, value) {\n\t\t\tif (that.hasEdge(from, to)) {\n\t\t\t\tthrow new JsGraph.EdgeExistsError(from, to, that.edgeValue(from, to));\n\t\t\t}\n\n\t\t\tthat.ensureVertex(from);\n\t\t\tthat.ensureVertex(to);\n\t\t\tthat.addNewEdge(from, to, value);\n\t\t};\n\n\t\tthat.setEdge = function (from, to, value) {\n\t\t\tif (!that.hasEdge(from, to)) {\n\t\t\t\tthrow new JsGraph.EdgeNotExistsError(from, to);\n\t\t\t}\n\n\t\t\t_edges[from][to] = value;\n\t\t};\n\n\t\tthat.spanEdge = function (from, to, value) {\n\t\t\tif (!that.hasVertex(from)) {\n\t\t\t\tif (that.hasVertex(to)) {\n\t\t\t\t\tthrow new JsGraph.VertexNotExistsError(from);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new JsGraph.VertexNotExistsError(from).v(to);\n\t\t\t\t}\n\t\t\t} else if (!that.hasVertex(to)) {\n\t\t\t\tthrow new JsGraph.VertexNotExistsError(to);\n\t\t\t}\n\n\t\t\tif (!that.hasEdge(from, to)) {\n\t\t\t\tthat.addNewEdge(from, to, value);\n\t\t\t}\n\t\t};\n\n\t\tthat.addEdge = function (from, to, value) {\n\t\t\tif (that.hasEdge(from, to)) {\n\t\t\t\tthat.setEdge(from, to, value);\n\t\t\t} else {\n\t\t\t\tthat.addNewEdge(from, to, value);\n\t\t\t}\n\t\t};\n\n\t\tthat.ensureEdge = function (from, to, value) {\n\t\t\tif (!that.hasEdge(from, to)) {\n\t\t\t\tthat.createNewEdge(from, to, value);\n\t\t\t}\n\t\t};\n\n\t\tthat.createEdge = function (from, to, value) {\n\t\t\tif (that.hasEdge(from, to)) {\n\t\t\t\tthat.setEdge(from, to, value);\n\t\t\t} else {\n\t\t\t\tthat.createNewEdge(from, to, value);\n\t\t\t}\n\t\t};\n\n\n\t\t//// removing them ////\n\t\t//\n\t\tthat.removeExistingEdge = function (from, to) {\n\t\t\tif (!that.hasEdge(from, to)) {\n\t\t\t\tthrow new JsGraph.EdgeNotExistsError(from, to);\n\t\t\t}\n\n\t\t\tvar valueOfRemovedEdge = _edges[from][to];\n\t\t\tdelete _edges[from][to];\n\t\t\tdelete _reverseEdges[to][from];\n\t\t\t_edgeCount -= 1;\n\t\t\t_removeEdgeCallbacks.fire(from, to, valueOfRemovedEdge);\n\t\t};\n\n\t\tthat.removeEdge = function (from, to) {\n\t\t\tif (that.hasEdge(from, to)) {\n\t\t\t\tthat.removeExistingEdge(from, to);\n\t\t\t}\n\t\t};\n\n\n\t\t///////////////////////////////////////////////////////////////////////////////////////////\n\n\n\t\tthat.vertexCount = function () {\n\t\t\treturn _vertexCount;\n\t\t};\n\n\n\t\tthat.hasVertex = function (key) {\n\t\t\treturn key in _vertices;\n\t\t};\n\n\n\t\tthat.vertexValue = function (key) {\n\t\t\treturn _vertices[key];\n\t\t};\n\n\n\t\t///////////////////////////////////////////////////////////////////////////////////////////\n\n\n\t\tthat.edgeCount = function () {\n\t\t\treturn _edgeCount;\n\t\t};\n\n\n\t\tthat.hasEdge = function (from, to) {\n\t\t\treturn that.hasVertex(from) &&\n\t\t\t       that.hasVertex(to) &&\n\t\t\t       from in _edges &&\n\t\t\t       to in _edges[from];\n\t\t};\n\n\n\t\tthat.edgeValue = function (from, to) {\n\t\t\treturn that.hasEdge(from, to) ? _edges[from][to] : undefined;\n\t\t};\n\n\n\t\t///////////////////////////////////////////////////////////////////////////////////////////\n\n\n\t\tthat.eachVertex = function (handler) {\n\t\t\tObject.keys(_vertices).forEach(function (key) {\n\t\t\t\thandler(key, _vertices[key]);\n\t\t\t});\n\t\t};\n\n\n\t\tthat.eachVertexFrom = function (from, handler) {\n\t\t\tif (!that.hasVertex(from)) {\n\t\t\t\tthrow new JsGraph.VertexNotExistsError(from);\n\t\t\t}\n\n\t\t\tObject.keys(_edges[from]).forEach(function (to) {\n\t\t\t\thandler(to, that.vertexValue(to), that.edgeValue(from, to));\n\t\t\t});\n\t\t};\n\n\n\t\tthat.eachVertexTo = function (to, handler) {\n\t\t\tif (!that.hasVertex(to)) {\n\t\t\t\tthrow new JsGraph.VertexNotExistsError(to);\n\t\t\t}\n\n\t\t\tObject.keys(_reverseEdges[to]).forEach(function (from) {\n\t\t\t\thandler(from, that.vertexValue(from), that.edgeValue(from, to));\n\t\t\t});\n\t\t};\n\n\n\t\tthat.eachEdge = function (handler) {\n\t\t\tObject.keys(_edges).forEach(function (from) {\n\t\t\t\tObject.keys(_edges[from]).forEach(function (to) {\n\t\t\t\t\thandler(from, to, _edges[from][to]);\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\n\t\tthat.clearEdges = function () {\n\t\t\tthat.eachEdge(that.removeEdge);\n\t\t};\n\n\n\t\tthat.clear = function () {\n\t\t\tthat.eachVertex(that.destroyVertex);\n\t\t};\n\n\n\t\tthat.hasPath = function (from, to) {\n\t\t\tif (!that.hasVertex(from) || !that.hasVertex(to)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar visited = {};\n\n\t\t\t//// Recursive auxiliary function: Is there a path from 'current' to 'to'?\n\t\t\t//\n\t\t\tfunction hasPathAux(current) {\n\t\t\t\tif (that.hasEdge(current, to)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvisited[current] = true;\n\t\t\t\tvar found = false;\n\t\t\t\tthat.eachVertexFrom(current, function (next) {\n\t\t\t\t\tif (!found && !visited[next] && hasPathAux(next)) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tdelete visited[current];\n\t\t\t\treturn found;\n\t\t\t}\n\n\t\t\treturn hasPathAux(from);\n\t\t};\n\n\t\tthat.topologically = function (handler) {\n\t\t\tvar visited = [];\n\t\t\tvar handled = {};\n\n\t\t\tfunction visit(a) {\n\t\t\t\tvisited.push(a);\n\n\t\t\t\tvar i = visited.indexOf(a);\n\t\t\t\tif (i !== visited.length - 1) {\n\t\t\t\t\tvar cycle = visited.slice(i + 1).reverse();\n                    console.error(cycle)\n\t\t\t\t\tthrow new JsGraph.CycleError(cycle);\n\t\t\t\t}\n\n\t\t\t\tif (!handled[a]) {\n\t\t\t\t\tthat.eachVertexTo(a, visit);\n\t\t\t\t\thandled[a] = { returned: handler(a, that.vertexValue(a)) };\n\t\t\t\t}\n\n\t\t\t\tvisited.pop();\n\t\t\t}\n\n\t\t\tthat.eachVertex(function (a) {\n\t\t\t\tif (!handled[a]) {\n\t\t\t\t\tvisit(a);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t}\n\n\n//  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//  // Utility /////////////////////////////////////////////////////////////////////////////////////////////////////////\n//  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\tfunction set2dObj(A, one, two, val) {\n\t\tif (typeof A[one] === 'undefined') {\n\t\t\tA[one] = {};\n\t\t}\n\t\tA[one][two] = val;\n\t}\n\n\n//  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//  // Callbacks ///////////////////////////////////////////////////////////////////////////////////////////////////////\n//  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\tfunction Callbacks() {\n\n\t\tvar callbacks = [];\n\n\t\tthis.add = function (fn) {\n\t\t\tif (callbacks.indexOf(fn) === -1) {\n\t\t\t\tcallbacks.push(fn);\n\t\t\t}\n\t\t\treturn function removeCallback() {\n\t\t\t\tvar index = callbacks.indexOf(fn);\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tcallbacks.splice(index, 1);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\tthis.fire = function () {\n\t\t\tvar args = arguments;\n\t\t\tcallbacks.forEach(function (fn) {\n\t\t\t\tfn.apply(null, args);\n\t\t\t});\n\t\t};\n\n\t}\n\n\n//  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//  // Errors //////////////////////////////////////////////////////////////////////////////////////////////////////////\n//  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\tfunction newError(name, constructor) {\n\t\t//noinspection JSUnusedGlobalSymbols\n\t\tconstructor.prototype.__proto__ = Error.prototype;\n\t\tconstructor.prototype.constructor = constructor;\n\t\tconstructor.prototype.name = name;\n\t\treturn constructor;\n\t}\n\n\n\tJsGraph.VertexExistsError = newError(\"VertexExistsError\", function (key, value) {\n\t\tvar that = this;\n\n\t\tfunction refreshMessage() {\n\t\t\tthat.message = \"This graph has \" +\n\t\t\t               (that.vertices === 1 ? \"a vertex\" : \"vertices\") +\n\t\t\t               \" '\" + Object.keys(that.vertices).join(\"', '\") + \"'\";\n\t\t}\n\n\t\tthat.v = function (key, value) {\n\t\t\tthat.vertices[key] = value;\n\t\t\trefreshMessage();\n\t\t\treturn that;\n\t\t};\n\n\t\tthat.vertices = {};\n\t\tthat.v(key, value);\n\n\t\trefreshMessage();\n\t});\n\n\n\tJsGraph.VertexNotExistsError = newError(\"VertexNotExistError\", function (key) {\n\t\tvar that = this;\n\n\t\tfunction refreshMessage() {\n\t\t\tthat.message = \"This graph does not have \" +\n\t\t\t               (that.vertices === 1 ? \"a vertex\" : \"vertices\") +\n\t\t\t               \" '\" + Object.keys(that.vertices).join(\"', '\") + \"'\";\n\t\t}\n\n\t\tthat.v = function (key) {\n\t\t\tthat.vertices[key] = undefined;\n\t\t\trefreshMessage();\n\t\t\treturn that;\n\t\t};\n\n\t\tthat.vertices = {};\n\t\tthat.v(key);\n\n\t\trefreshMessage();\n\t});\n\n\n\tJsGraph.EdgeExistsError = newError(\"EdgeExistsError\", function (from, to, value) {\n\t\tvar that = this;\n\n\t\tfunction refreshMessage() {\n\t\t\tvar edges = [];\n\n\t\t\tObject.keys(that.edges).forEach(function (from) {\n\t\t\t\tObject.keys(that.edges[from]).forEach(function (to) {\n\t\t\t\t\tedges.push(\"('\" + from + \"', '\" + to + \"')\");\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tthat.message = \"This graph has \" +\n\t\t\t               (edges.length === 1 ? \"an edge \" : \"edges \") +\n\t\t\t               edges.join(\", \");\n\t\t}\n\n\t\tthat.e = function (from, to, value) {\n\t\t\tset2dObj(that.edges, from, to, value);\n\t\t\trefreshMessage();\n\t\t\treturn that;\n\t\t};\n\n\t\tthat.edges = {};\n\t\tthat.e(from, to, value);\n\n\t\trefreshMessage();\n\t});\n\n\n\tJsGraph.EdgeNotExistsError = newError(\"EdgeNotExistError\", function (from, to) {\n\t\tvar that = this;\n\n\t\tfunction refreshMessage() {\n\t\t\tvar edges = [];\n\n\t\t\tObject.keys(that.edges).forEach(function (from) {\n\t\t\t\tObject.keys(that.edges[from]).forEach(function (to) {\n\t\t\t\t\tedges.push(\"('\" + from + \"', '\" + to + \"')\");\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tthat.message = \"This graph does not have \" +\n\t\t\t               (edges.length === 1 ? \"an edge \" : \"edges \") +\n\t\t\t               edges.join(\", \");\n\t\t}\n\n\t\tthat.e = function (from, to) {\n\t\t\tset2dObj(that.edges, from, to, undefined);\n\t\t\trefreshMessage();\n\t\t\treturn that;\n\t\t};\n\n\t\tthat.edges = {};\n\t\tthat.e(from, to);\n\n\t\trefreshMessage();\n\t});\n\n\n\tJsGraph.HasConnectedEdgesError = newError(\"HasConnectedEdgesError\", function (key) {\n\t\tthis.message = \"The '\" + key + \"' vertex has connected edges\";\n\t\tthis.key = key;\n\t});\n\n\n\tJsGraph.CycleError = newError(\"CycleError\", function (cycle) {\n\t\tthis.message = \"This graph contains a cycle: \" + this.cycle;\n\t\tthis.cycle = cycle;\n\t});\n\n\n//  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\treturn JsGraph;\n\n\n}));////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n","/home/travis/build/npmtest/node-npmtest-node-uglifier/node_modules/node-uglifier/lib_compiled/libs/packageUtils.js":"// Generated by CoffeeScript 1.10.0\n(function() {\n  var UglifyJS, _, fs, fsExtra, packageUtils, path, strEscapeMap;\n\n  fsExtra = require('fs-extra');\n\n  fs = require('fs');\n\n  UglifyJS = require('uglify-js-harmony');\n\n  path = require('path');\n\n  _ = require('underscore');\n\n  packageUtils = module.exports;\n\n  packageUtils.isNative = function(module) {\n    var err, error;\n    try {\n      return require.resolve(module) === module;\n    } catch (error) {\n      err = error;\n      return false;\n    }\n  };\n\n  packageUtils.readFile = function(pathAbs, encoding) {\n    var options;\n    if (encoding == null) {\n      encoding = 'utf8';\n    }\n    options = {\n      encoding: encoding\n    };\n    return fs.readFileSync(pathAbs, options);\n  };\n\n  packageUtils.getAst = function(code) {\n    return UglifyJS.parse(code);\n  };\n\n  packageUtils.getMatchingFiles = function(rootPath, dirAndFileArray) {\n    var destination, dirOrFile, error, fileName, filestats, j, len, me, r, rootDir;\n    r = [];\n    rootDir = fs.lstatSync(rootPath).isDirectory() ? path.resolve(rootPath) : path.dirname(path.resolve(rootPath));\n    for (j = 0, len = dirAndFileArray.length; j < len; j++) {\n      dirOrFile = dirAndFileArray[j];\n      destination = path.resolve(rootDir, dirOrFile);\n      try {\n        filestats = fs.lstatSync(destination);\n      } catch (error) {\n        me = error;\n        filestats = null;\n      }\n      if (filestats && filestats.isDirectory()) {\n        fs.readdirSync(destination).reduce((function(prev, curr) {\n          prev.push(path.join(destination, curr));\n          return prev;\n        }), r);\n      } else {\n        if (path.extname(destination) === \"\") {\n          fileName = path.basename(destination);\n          fs.readdirSync(path.dirname(destination)).filter(function(fileNameLoc) {\n            return fileNameLoc.indexOf(fileName) !== -1;\n          }).reduce((function(prev, curr) {\n            prev.push(path.join(destination, curr));\n            return prev;\n          }), r);\n        } else {\n          r.push(destination);\n        }\n      }\n    }\n    return r;\n  };\n\n  packageUtils.getIfNonNativeNotFilteredNonNpm = function(fileAbs, filters, possibleExtensions) {\n    var existingExtensions, r;\n    r = null;\n    if (path.extname(fileAbs) === \"\") {\n      existingExtensions = possibleExtensions.filter(function(ext) {\n        return fs.existsSync(fileAbs + \".\" + ext);\n      });\n      if (existingExtensions.length > 1) {\n        throw new Error(\" multiple matching extensions problem for \" + fileAbs);\n      }\n      r = existingExtensions.length === 1 ? fileAbs + \".\" + existingExtensions[0] : null;\n    } else {\n      r = fs.existsSync(fileAbs) ? fileAbs : null;\n    }\n    if (r) {\n      if (filters.filter(function(fFile) {\n        return path.normalize(fFile) === path.normalize(r);\n      }).length > 0) {\n        r = null;\n        console.log(fileAbs + \" was filtered \");\n      }\n    }\n    return r;\n  };\n\n  packageUtils.walkExpressions = function(astNode, parentNode, depth) {\n    if (depth > 5) {\n      return null;\n    }\n    if (astNode.name === \"require\") {\n      return (parentNode != null ? parentNode.args : void 0) || astNode.args;\n    } else if (astNode.expression != null) {\n      return packageUtils.walkExpressions(astNode.expression, astNode, depth + 1);\n    }\n  };\n\n  packageUtils.getRequireStatements = function(ast, file, possibleExtensions, packNodeModules) {\n    var fileDir, handleRequireNode, r;\n    if (possibleExtensions == null) {\n      possibleExtensions = [\"js\", \"coffee\"];\n    }\n    if (packNodeModules == null) {\n      packNodeModules = false;\n    }\n    r = [];\n    fileDir = path.dirname(file);\n    handleRequireNode = function(text, args) {\n      var error, hasPathInIt, me, pathOfModule, pathOfModuleLoc, pathOfModuleLocStats, pathOfModuleRaw, rs;\n      pathOfModuleRaw = args[0].value;\n      if (pathOfModuleRaw == null) {\n        throw new Error(\"probably dynamic\");\n      }\n      hasPathInIt = !_.isEmpty(pathOfModuleRaw.match(\"/\")) || !_.isEmpty(pathOfModuleRaw.match(/\\\\/));\n      if (hasPathInIt) {\n\n      } else if (packNodeModules) {\n        pathOfModuleRaw = require.resolve(pathOfModuleRaw);\n      } else {\n        return false;\n      }\n      pathOfModuleLoc = path.resolve(fileDir, pathOfModuleRaw);\n      try {\n        pathOfModuleLocStats = fs.lstatSync(pathOfModuleLoc);\n      } catch (error) {\n        me = error;\n      }\n      if (pathOfModuleLocStats && pathOfModuleLocStats.isDirectory()) {\n        pathOfModuleLoc = path.resolve(pathOfModuleLoc, \"index\");\n      }\n      pathOfModule = packageUtils.getIfNonNativeNotFilteredNonNpm(pathOfModuleLoc, [], possibleExtensions);\n      rs = {\n        text: text,\n        path: pathOfModule\n      };\n      if (pathOfModule) {\n        return r.push(rs);\n      }\n    };\n    ast.walk(new UglifyJS.TreeWalker(function(node) {\n      var args, error, me, ref, requireArgs, text, text2, walkedArgs;\n      if ((node instanceof UglifyJS.AST_Call) && (node.start.value === 'require' || (node.start.value === 'new' && node.expression.print_to_string() === \"require\"))) {\n        text = node.print_to_string({\n          beautify: false\n        });\n        requireArgs = node != null ? (ref = node.expression) != null ? ref.args : void 0 : void 0;\n        walkedArgs = packageUtils.walkExpressions(node, null, 1);\n        if (_.isEmpty(requireArgs)) {\n          requireArgs = node.args;\n        }\n        try {\n          if (requireArgs.length !== 1 || !handleRequireNode(text, requireArgs) && !_.isEmpty(walkedArgs)) {\n            text2 = \"require('\" + walkedArgs[0].value + \"')\";\n            handleRequireNode(text2, walkedArgs);\n          }\n        } catch (error) {\n          me = error;\n          console.log(\"Warning!:\");\n          console.log(\"unhandled require type in file: \" + file + \" the problematic statement: \" + text + \" probably something fancy going on! \" + \" the error: \" + me.message);\n        }\n        return true;\n      } else if ((node instanceof UglifyJS.AST_Call) && (node.start.value === 'new' && node.expression.start.value === \"(\" && node.expression.print_to_string().indexOf(\"require\") !== -1)) {\n        args = node.expression.args;\n        text = \"require\" + \"('\" + args[0].value + \"')\";\n        handleRequireNode(text, args);\n        console.log(\"second \" + text);\n        return true;\n      } else {\n\n      }\n    }));\n    return r;\n  };\n\n  strEscapeMap = {\n    '\\b': '\\\\b',\n    '\\f': '\\\\f',\n    '\\n': '\\\\n',\n    '\\r': '\\\\r',\n    '\\t': '\\\\t'\n  };\n\n  packageUtils.hexifyString = function(str) {\n    var char, i, j, r, ref;\n    r = \"\";\n    if (!str.length > 0) {\n      return r;\n    }\n    for (i = j = 0, ref = str.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {\n      char = str[i];\n      if (strEscapeMap[char]) {\n        r += r[char];\n      } else if ('\\\\' === char) {\n        r += '\\\\' + str[++i];\n      } else {\n        r += '\\\\x' + str.charCodeAt(i).toString(16);\n      }\n    }\n    return r;\n  };\n\n  packageUtils.deHexifyString = function(str) {\n    return str.toString();\n  };\n\n  packageUtils.getSourceHexified = function(ast) {\n    var hexify, stream, transformer;\n    hexify = function(node) {\n      var hex, obj, text;\n      if (node instanceof UglifyJS.AST_String) {\n        text = node.getValue();\n        hex = packageUtils.hexifyString(text);\n        obj = _.extend({}, node);\n        obj.value = hex;\n        return new UglifyJS.AST_String(obj);\n      } else {\n\n      }\n    };\n    transformer = new UglifyJS.TreeTransformer(null, hexify);\n    stream = new UglifyJS.OutputStream;\n    stream.print_string = function(str) {\n      return this.print('\"' + str + '\"');\n    };\n    ast = ast.transform(transformer);\n    ast.print(stream);\n    return stream.toString();\n  };\n\n  packageUtils.replaceRequireStatement = function(textIn, orig, replacement) {\n    var isReplaced, text, withTheOtherQuotation;\n    text = textIn;\n    isReplaced = false;\n    text = text.replace(orig, function(token) {\n      isReplaced = true;\n      return replacement;\n    });\n    if (!isReplaced) {\n      withTheOtherQuotation = orig;\n      if (withTheOtherQuotation.indexOf(\"'\") !== -1) {\n        withTheOtherQuotation = withTheOtherQuotation.replace(/[']/ig, '\"');\n      } else {\n        withTheOtherQuotation = withTheOtherQuotation.replace(/[\"]/ig, \"'\");\n      }\n      text = text.replace(withTheOtherQuotation, function(token) {\n        isReplaced = true;\n        return replacement;\n      });\n    }\n    if (!isReplaced) {\n      throw new Error(orig + \" was not replaced with \" + replacement);\n    }\n    return text;\n  };\n\n  packageUtils.countWords = function(sentence) {\n    var index, words;\n    index = {};\n    words = sentence.replace(/[.,?!;()\"'-]/g, \" \").replace(/\\s+/g, \" \").toLowerCase().split(\" \");\n    words.forEach(function(word) {\n      if (!(index.hasOwnProperty(word))) {\n        index[word] = 0;\n      }\n      return index[word]++;\n    });\n    return index;\n  };\n\n}).call(this);\n\n//# sourceMappingURL=packageUtils.js.map\n","/home/travis/build/npmtest/node-npmtest-node-uglifier/node_modules/node-uglifier/lib_compiled/libs/cryptoUtils.js":"// Generated by CoffeeScript 1.10.0\n(function() {\n  var _, crypto, cryptoUtils, seedrandom, sugar;\n\n  _ = require('underscore');\n\n  sugar = require('sugar');\n\n  crypto = require(\"crypto\");\n\n  seedrandom = require(\"seedrandom\");\n\n  cryptoUtils = module.exports;\n\n  cryptoUtils.generateSalt = function(saltLength) {\n    return crypto.randomBytes(Math.ceil(saltLength / 2)).toString('hex').substring(0, saltLength);\n  };\n\n  cryptoUtils.getSaltedHash = function(message, hashAlgorithm, salt) {\n    return crypto.createHmac(hashAlgorithm, salt).update(message).digest('hex');\n  };\n\n  cryptoUtils.shuffleArray = function(array, seed) {\n    var i, j, k, randFnc, ref, temp;\n    if (seed == null) {\n      seed = null;\n    }\n    randFnc = Math.random;\n    if (seed) {\n      randFnc = seedrandom(seed);\n    }\n    for (i = k = ref = array.length - 1; ref <= 0 ? k <= 0 : k >= 0; i = ref <= 0 ? ++k : --k) {\n      j = Math.floor(randFnc() * (i + 1));\n      temp = array[i];\n      array[i] = array[j];\n      array[j] = temp;\n    }\n    return array;\n  };\n\n}).call(this);\n\n//# sourceMappingURL=cryptoUtils.js.map\n","/home/travis/build/npmtest/node-npmtest-node-uglifier/node_modules/node-uglifier/lib_compiled/ipaddr.js":"// Generated by CoffeeScript 1.10.0\n(function() {\n  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root;\n\n  ipaddr = {};\n\n  root = this;\n\n  if ((typeof module !== \"undefined\" && module !== null) && module.exports) {\n    module.exports = ipaddr;\n  } else {\n    root['ipaddr'] = ipaddr;\n  }\n\n  matchCIDR = function(first, second, partSize, cidrBits) {\n    var part, shift;\n    if (first.length !== second.length) {\n      throw new Error(\"ipaddr: cannot match CIDR for objects with different lengths\");\n    }\n    part = 0;\n    while (cidrBits > 0) {\n      shift = partSize - cidrBits;\n      if (shift < 0) {\n        shift = 0;\n      }\n      if (first[part] >> shift !== second[part] >> shift) {\n        return false;\n      }\n      cidrBits -= partSize;\n      part += 1;\n    }\n    return true;\n  };\n\n  ipaddr.subnetMatch = function(address, rangeList, defaultName) {\n    var j, len, rangeName, rangeSubnets, subnet;\n    if (defaultName == null) {\n      defaultName = 'unicast';\n    }\n    for (rangeName in rangeList) {\n      rangeSubnets = rangeList[rangeName];\n      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {\n        rangeSubnets = [rangeSubnets];\n      }\n      for (j = 0, len = rangeSubnets.length; j < len; j++) {\n        subnet = rangeSubnets[j];\n        if (address.match.apply(address, subnet)) {\n          return rangeName;\n        }\n      }\n    }\n    return defaultName;\n  };\n\n  ipaddr.IPv4 = (function() {\n    function IPv4(octets) {\n      var j, len, octet;\n      if (octets.length !== 4) {\n        throw new Error(\"ipaddr: ipv4 octet count should be 4\");\n      }\n      for (j = 0, len = octets.length; j < len; j++) {\n        octet = octets[j];\n        if (!((0 <= octet && octet <= 255))) {\n          throw new Error(\"ipaddr: ipv4 octet should fit in 8 bits\");\n        }\n      }\n      this.octets = octets;\n    }\n\n    IPv4.prototype.kind = function() {\n      return 'ipv4';\n    };\n\n    IPv4.prototype.toString = function() {\n      return this.octets.join(\".\");\n    };\n\n    IPv4.prototype.toByteArray = function() {\n      return this.octets.slice(0);\n    };\n\n    IPv4.prototype.match = function(other, cidrRange) {\n      var ref;\n      if (cidrRange === void 0) {\n        ref = other, other = ref[0], cidrRange = ref[1];\n      }\n      if (other.kind() !== 'ipv4') {\n        throw new Error(\"ipaddr: cannot match ipv4 address with non-ipv4 one\");\n      }\n      return matchCIDR(this.octets, other.octets, 8, cidrRange);\n    };\n\n    IPv4.prototype.SpecialRanges = {\n      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],\n      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],\n      multicast: [[new IPv4([224, 0, 0, 0]), 4]],\n      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],\n      loopback: [[new IPv4([127, 0, 0, 0]), 8]],\n      carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],\n      \"private\": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],\n      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]\n    };\n\n    IPv4.prototype.range = function() {\n      return ipaddr.subnetMatch(this, this.SpecialRanges);\n    };\n\n    IPv4.prototype.toIPv4MappedAddress = function() {\n      return ipaddr.IPv6.parse(\"::ffff:\" + (this.toString()));\n    };\n\n    IPv4.prototype.prefixLengthFromSubnetMask = function() {\n      var cidr, i, j, octet, stop, zeros, zerotable;\n      zerotable = {\n        0: 8,\n        128: 7,\n        192: 6,\n        224: 5,\n        240: 4,\n        248: 3,\n        252: 2,\n        254: 1,\n        255: 0\n      };\n      cidr = 0;\n      stop = false;\n      for (i = j = 3; j >= 0; i = j += -1) {\n        octet = this.octets[i];\n        if (octet in zerotable) {\n          zeros = zerotable[octet];\n          if (stop && zeros !== 0) {\n            return null;\n          }\n          if (zeros !== 8) {\n            stop = true;\n          }\n          cidr += zeros;\n        } else {\n          return null;\n        }\n      }\n      return 32 - cidr;\n    };\n\n    return IPv4;\n\n  })();\n\n  ipv4Part = \"(0?\\\\d+|0x[a-f0-9]+)\";\n\n  ipv4Regexes = {\n    fourOctet: new RegExp(\"^\" + ipv4Part + \"\\\\.\" + ipv4Part + \"\\\\.\" + ipv4Part + \"\\\\.\" + ipv4Part + \"$\", 'i'),\n    longValue: new RegExp(\"^\" + ipv4Part + \"$\", 'i')\n  };\n\n  ipaddr.IPv4.parser = function(string) {\n    var match, parseIntAuto, part, shift, value;\n    parseIntAuto = function(string) {\n      if (string[0] === \"0\" && string[1] !== \"x\") {\n        return parseInt(string, 8);\n      } else {\n        return parseInt(string);\n      }\n    };\n    if (match = string.match(ipv4Regexes.fourOctet)) {\n      return (function() {\n        var j, len, ref, results;\n        ref = match.slice(1, 6);\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n          part = ref[j];\n          results.push(parseIntAuto(part));\n        }\n        return results;\n      })();\n    } else if (match = string.match(ipv4Regexes.longValue)) {\n      value = parseIntAuto(match[1]);\n      if (value > 0xffffffff || value < 0) {\n        throw new Error(\"ipaddr: address outside defined range\");\n      }\n      return ((function() {\n        var j, results;\n        results = [];\n        for (shift = j = 0; j <= 24; shift = j += 8) {\n          results.push((value >> shift) & 0xff);\n        }\n        return results;\n      })()).reverse();\n    } else {\n      return null;\n    }\n  };\n\n  ipaddr.IPv6 = (function() {\n    function IPv6(parts) {\n      var i, j, k, len, part, ref;\n      if (parts.length === 16) {\n        this.parts = [];\n        for (i = j = 0; j <= 14; i = j += 2) {\n          this.parts.push((parts[i] << 8) | parts[i + 1]);\n        }\n      } else if (parts.length === 8) {\n        this.parts = parts;\n      } else {\n        throw new Error(\"ipaddr: ipv6 part count should be 8 or 16\");\n      }\n      ref = this.parts;\n      for (k = 0, len = ref.length; k < len; k++) {\n        part = ref[k];\n        if (!((0 <= part && part <= 0xffff))) {\n          throw new Error(\"ipaddr: ipv6 part should fit in 16 bits\");\n        }\n      }\n    }\n\n    IPv6.prototype.kind = function() {\n      return 'ipv6';\n    };\n\n    IPv6.prototype.toString = function() {\n      var compactStringParts, j, len, part, pushPart, state, stringParts;\n      stringParts = (function() {\n        var j, len, ref, results;\n        ref = this.parts;\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n          part = ref[j];\n          results.push(part.toString(16));\n        }\n        return results;\n      }).call(this);\n      compactStringParts = [];\n      pushPart = function(part) {\n        return compactStringParts.push(part);\n      };\n      state = 0;\n      for (j = 0, len = stringParts.length; j < len; j++) {\n        part = stringParts[j];\n        switch (state) {\n          case 0:\n            if (part === '0') {\n              pushPart('');\n            } else {\n              pushPart(part);\n            }\n            state = 1;\n            break;\n          case 1:\n            if (part === '0') {\n              state = 2;\n            } else {\n              pushPart(part);\n            }\n            break;\n          case 2:\n            if (part !== '0') {\n              pushPart('');\n              pushPart(part);\n              state = 3;\n            }\n            break;\n          case 3:\n            pushPart(part);\n        }\n      }\n      if (state === 2) {\n        pushPart('');\n        pushPart('');\n      }\n      return compactStringParts.join(\":\");\n    };\n\n    IPv6.prototype.toByteArray = function() {\n      var bytes, j, len, part, ref;\n      bytes = [];\n      ref = this.parts;\n      for (j = 0, len = ref.length; j < len; j++) {\n        part = ref[j];\n        bytes.push(part >> 8);\n        bytes.push(part & 0xff);\n      }\n      return bytes;\n    };\n\n    IPv6.prototype.toNormalizedString = function() {\n      var part;\n      return ((function() {\n        var j, len, ref, results;\n        ref = this.parts;\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n          part = ref[j];\n          results.push(part.toString(16));\n        }\n        return results;\n      }).call(this)).join(\":\");\n    };\n\n    IPv6.prototype.match = function(other, cidrRange) {\n      var ref;\n      if (cidrRange === void 0) {\n        ref = other, other = ref[0], cidrRange = ref[1];\n      }\n      if (other.kind() !== 'ipv6') {\n        throw new Error(\"ipaddr: cannot match ipv6 address with non-ipv6 one\");\n      }\n      return matchCIDR(this.parts, other.parts, 16, cidrRange);\n    };\n\n    IPv6.prototype.SpecialRanges = {\n      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],\n      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],\n      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],\n      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],\n      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],\n      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],\n      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],\n      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],\n      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],\n      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],\n      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]\n    };\n\n    IPv6.prototype.range = function() {\n      return ipaddr.subnetMatch(this, this.SpecialRanges);\n    };\n\n    IPv6.prototype.isIPv4MappedAddress = function() {\n      return this.range() === 'ipv4Mapped';\n    };\n\n    IPv6.prototype.toIPv4Address = function() {\n      var high, low, ref;\n      if (!this.isIPv4MappedAddress()) {\n        throw new Error(\"ipaddr: trying to convert a generic ipv6 address to ipv4\");\n      }\n      ref = this.parts.slice(-2), high = ref[0], low = ref[1];\n      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);\n    };\n\n    return IPv6;\n\n  })();\n\n  ipv6Part = \"(?:[0-9a-f]+::?)+\";\n\n  ipv6Regexes = {\n    \"native\": new RegExp(\"^(::)?(\" + ipv6Part + \")?([0-9a-f]+)?(::)?$\", 'i'),\n    transitional: new RegExp((\"^((?:\" + ipv6Part + \")|(?:::)(?:\" + ipv6Part + \")?)\") + (ipv4Part + \"\\\\.\" + ipv4Part + \"\\\\.\" + ipv4Part + \"\\\\.\" + ipv4Part + \"$\"), 'i')\n  };\n\n  expandIPv6 = function(string, parts) {\n    var colonCount, lastColon, part, replacement, replacementCount;\n    if (string.indexOf('::') !== string.lastIndexOf('::')) {\n      return null;\n    }\n    colonCount = 0;\n    lastColon = -1;\n    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {\n      colonCount++;\n    }\n    if (string.substr(0, 2) === '::') {\n      colonCount--;\n    }\n    if (string.substr(-2, 2) === '::') {\n      colonCount--;\n    }\n    if (colonCount > parts) {\n      return null;\n    }\n    replacementCount = parts - colonCount;\n    replacement = ':';\n    while (replacementCount--) {\n      replacement += '0:';\n    }\n    string = string.replace('::', replacement);\n    if (string[0] === ':') {\n      string = string.slice(1);\n    }\n    if (string[string.length - 1] === ':') {\n      string = string.slice(0, -1);\n    }\n    return (function() {\n      var j, len, ref, results;\n      ref = string.split(\":\");\n      results = [];\n      for (j = 0, len = ref.length; j < len; j++) {\n        part = ref[j];\n        results.push(parseInt(part, 16));\n      }\n      return results;\n    })();\n  };\n\n  ipaddr.IPv6.parser = function(string) {\n    var j, len, match, octet, octets, parts;\n    if (string.match(ipv6Regexes['native'])) {\n      return expandIPv6(string, 8);\n    } else if (match = string.match(ipv6Regexes['transitional'])) {\n      parts = expandIPv6(match[1].slice(0, -1), 6);\n      if (parts) {\n        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];\n        for (j = 0, len = octets.length; j < len; j++) {\n          octet = octets[j];\n          if (!((0 <= octet && octet <= 255))) {\n            return null;\n          }\n        }\n        parts.push(octets[0] << 8 | octets[1]);\n        parts.push(octets[2] << 8 | octets[3]);\n        return parts;\n      }\n    }\n    return null;\n  };\n\n  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {\n    return this.parser(string) !== null;\n  };\n\n  ipaddr.IPv4.isValid = function(string) {\n    var e, error;\n    try {\n      new this(this.parser(string));\n      return true;\n    } catch (error) {\n      e = error;\n      return false;\n    }\n  };\n\n  ipaddr.IPv4.isValidFourPartDecimal = function(string) {\n    if (ipaddr.IPv4.isValid(string) && string.match(/^\\d+(\\.\\d+){3}$/)) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  ipaddr.IPv6.isValid = function(string) {\n    var e, error;\n    if (typeof string === \"string\" && string.indexOf(\":\") === -1) {\n      return false;\n    }\n    try {\n      new this(this.parser(string));\n      return true;\n    } catch (error) {\n      e = error;\n      return false;\n    }\n  };\n\n  ipaddr.IPv4.parse = ipaddr.IPv6.parse = function(string) {\n    var parts;\n    parts = this.parser(string);\n    if (parts === null) {\n      throw new Error(\"ipaddr: string is not formatted like ip address\");\n    }\n    return new this(parts);\n  };\n\n  ipaddr.IPv4.parseCIDR = function(string) {\n    var maskLength, match;\n    if (match = string.match(/^(.+)\\/(\\d+)$/)) {\n      maskLength = parseInt(match[2]);\n      if (maskLength >= 0 && maskLength <= 32) {\n        return [this.parse(match[1]), maskLength];\n      }\n    }\n    throw new Error(\"ipaddr: string is not formatted like an IPv4 CIDR range\");\n  };\n\n  ipaddr.IPv6.parseCIDR = function(string) {\n    var maskLength, match;\n    if (match = string.match(/^(.+)\\/(\\d+)$/)) {\n      maskLength = parseInt(match[2]);\n      if (maskLength >= 0 && maskLength <= 128) {\n        return [this.parse(match[1]), maskLength];\n      }\n    }\n    throw new Error(\"ipaddr: string is not formatted like an IPv6 CIDR range\");\n  };\n\n  ipaddr.isValid = function(string) {\n    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);\n  };\n\n  ipaddr.parse = function(string) {\n    if (ipaddr.IPv6.isValid(string)) {\n      return ipaddr.IPv6.parse(string);\n    } else if (ipaddr.IPv4.isValid(string)) {\n      return ipaddr.IPv4.parse(string);\n    } else {\n      throw new Error(\"ipaddr: the address has neither IPv6 nor IPv4 format\");\n    }\n  };\n\n  ipaddr.parseCIDR = function(string) {\n    var e, error, error1;\n    try {\n      return ipaddr.IPv6.parseCIDR(string);\n    } catch (error) {\n      e = error;\n      try {\n        return ipaddr.IPv4.parseCIDR(string);\n      } catch (error1) {\n        e = error1;\n        throw new Error(\"ipaddr: the address has neither IPv6 nor IPv4 CIDR format\");\n      }\n    }\n  };\n\n  ipaddr.fromByteArray = function(bytes) {\n    var length;\n    length = bytes.length;\n    if (length === 4) {\n      return new ipaddr.IPv4(bytes);\n    } else if (length === 16) {\n      return new ipaddr.IPv6(bytes);\n    } else {\n      throw new Error(\"ipaddr: the binary input is neither an IPv6 nor IPv4 address\");\n    }\n  };\n\n  ipaddr.process = function(string) {\n    var addr;\n    addr = this.parse(string);\n    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {\n      return addr.toIPv4Address();\n    } else {\n      return addr;\n    }\n  };\n\n}).call(this);\n\n//# sourceMappingURL=ipaddr.js.map\n","/home/travis/build/npmtest/node-npmtest-node-uglifier/node_modules/node-uglifier/temp/totalObfuscator.js":"// Generated by CoffeeScript 1.7.1\n(function() {\n  var TotalObfuscator, cryptoUtils, fs, fsExtra, packageUtils, path, saltLength, sh, sugar, _;\n\n  fsExtra = require('fs-extra');\n\n  fs = require('fs');\n\n  _ = require('underscore');\n\n  sugar = require('sugar');\n\n  path = require('path');\n\n  sh = require('execSync');\n\n  packageUtils = require('./libs/packageUtils');\n\n  cryptoUtils = require('./libs/cryptoUtils');\n\n  saltLength = 20;\n\n  TotalObfuscator = (function() {\n    function TotalObfuscator(mainFile, options) {\n      var _i, _results;\n      if (options == null) {\n        options = {};\n      }\n      this.options = {\n        leaveDirAsExternal: []\n      };\n      _.extend(this.options, options);\n      this.mainFileAbs = path.resolve(mainFile);\n      if (!fs.existsSync(this.mainFileAbs)) {\n        throw new Error(\"main file not found\");\n      } else {\n        console.log(\"processing main file: \" + this.mainFileAbs);\n      }\n      this.salt = cryptoUtils.generateSalt(saltLength);\n      this.hashAlgorithm = \"sha1\";\n      this.wrappedSourceContainerName = \"cachedModules\";\n      this.serialMappings = cryptoUtils.shuffleArray((function() {\n        _results = [];\n        for (_i = 0; _i <= 10000; _i++){ _results.push(_i); }\n        return _results;\n      }).apply(this));\n      this._sourceCodes = {};\n      this.lastResult = null;\n    }\n\n    TotalObfuscator.prototype.getSourceContainer = function(serial) {\n      return this.wrappedSourceContainerName + \"[\" + this.serialMappings[serial] + \"]\";\n    };\n\n    TotalObfuscator.prototype.getRequireSubstitutionForMerge = function(serial) {\n      return this.getSourceContainer(serial) + \".exports\";\n    };\n\n    TotalObfuscator.prototype.addWrapper = function(source, serial) {\n      var firstLine, lastLine, modulesArrayStr, secondLine;\n      modulesArrayStr = this.getSourceContainer(serial);\n      firstLine = modulesArrayStr + \"={exports:{}};\" + \"\\n\";\n      secondLine = \"(function(module,exports) {\";\n      lastLine = \"}).call(this,\" + modulesArrayStr + \",\" + modulesArrayStr + \".exports);\";\n      return \"\\n\" + firstLine + secondLine + source + lastLine;\n    };\n\n    TotalObfuscator.prototype.combine = function() {\n      var firstLine, r, recursiveSourceGrabber, _this;\n      _this = this;\n      firstLine = \"var \" + this.wrappedSourceContainerName + \"=[];\";\n      r = firstLine;\n      recursiveSourceGrabber = function(filePath) {\n        var ast, isReplaced, otherSerial, pathSaltedHash, requireStatement, requireStatements, serial, source, sourceMod, withTheOtherQuotation, _i, _len;\n        source = packageUtils.readFile(filePath).toString();\n        pathSaltedHash = cryptoUtils.getSaltedHash(filePath, _this.hashAlgorithm, _this.salt);\n        if (_this._sourceCodes[pathSaltedHash] == null) {\n          _this._sourceCodes[pathSaltedHash] = {\n            source: source,\n            serial: _.keys(_this._sourceCodes).length\n          };\n          console.log(filePath + \" added to sources \");\n        }\n        serial = _this._sourceCodes[pathSaltedHash].serial;\n        ast = packageUtils.getAst(source);\n        requireStatements = packageUtils.getRequireStatements(ast, filePath);\n        requireStatements.each(function(o, i) {\n          return requireStatements[i] = _.extend(o, {\n            pathSaltedHash: cryptoUtils.getSaltedHash(o.path, _this.hashAlgorithm, _this.salt)\n          });\n        });\n        sourceMod = source;\n        for (_i = 0, _len = requireStatements.length; _i < _len; _i++) {\n          requireStatement = requireStatements[_i];\n          if (_this._sourceCodes[requireStatement.pathSaltedHash] == null) {\n            recursiveSourceGrabber(requireStatement.path);\n          }\n          if (_this._sourceCodes[requireStatement.pathSaltedHash] == null) {\n            throw new Error(\" internal should not happen 1\");\n          }\n          otherSerial = _this._sourceCodes[requireStatement.pathSaltedHash].serial;\n          isReplaced = false;\n          sourceMod = sourceMod.replace(requireStatement.text, function(token) {\n            isReplaced = true;\n            return _this.getRequireSubstitution(otherSerial);\n          });\n          if (!isReplaced) {\n            withTheOtherQuotation = requireStatement.text;\n            if (withTheOtherQuotation.indexOf(\"'\") !== -1) {\n              withTheOtherQuotation = withTheOtherQuotation.replace(/[']/ig, '\"');\n            } else {\n              withTheOtherQuotation = withTheOtherQuotation.replace(/[\"]/ig, \"'\");\n            }\n            sourceMod = sourceMod.replace(withTheOtherQuotation, function(token) {\n              isReplaced = true;\n              return _this.getRequireSubstitution(otherSerial);\n            });\n          }\n          if (!isReplaced) {\n            throw new Error(requireStatement.text + \" was not replaced with \" + _this.getRequireSubstitution(otherSerial));\n          }\n        }\n        _this._sourceCodes[pathSaltedHash].sourceMod = sourceMod;\n        if (serial > 0) {\n          _this._sourceCodes[pathSaltedHash].sourceModWrapped = _this.addWrapper(sourceMod, serial);\n        } else {\n          _this._sourceCodes[pathSaltedHash].sourceModWrapped = sourceMod;\n        }\n        return r = r + _this._sourceCodes[pathSaltedHash].sourceModWrapped;\n      };\n      recursiveSourceGrabber(this.mainFileAbs);\n      return this.lastResult = r;\n    };\n\n    return TotalObfuscator;\n\n  })();\n\n  new TotalObfuscator(\"lib_compiled/test/test.js\").combine();\n\n}).call(this);\n\n//# sourceMappingURL=totalObfuscator.map\n"}